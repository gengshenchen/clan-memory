
数据库 Schema 设计 (SQLite):

Members (成员表): ID, 姓名, 性别, 生卒日期, 简介, 头像路径。
Relationships (关系表): ID, SourceID (父/母), TargetID (子), Type (父子/夫妻)。
Events (事迹表): ID, MemberID, 日期, 标题, 详情, 地点 (用于时间轴)。
Media (多媒体表): ID, 关联对象ID, 文件路径, 类型 (照片/视频/文档)。

C++ DAO 层封装 (DatabaseManager):
实现 AddMember, UpdateMember, DeleteMember。
实现复杂的查询逻辑：比如 GetAncestors(id) (查祖先) 和 GetDescendants(id) (查子孙)。

第三阶段：JSBridge 交互通道 (联通 React 与 C++)
利用你已经有的 js_bridge.cpp，打通 Web 界面和 C++ 数据库的“任督二脉”。
C++ -> Web:
当数据库数据更新时，发射信号通知 Web 刷新图表。
cefView->sendEvent("updateTreeData", jsonPayload);
Web -> C++:

React 组件中点击“保存” -> 调用 CallBridge.saveMember(data) -> C++ 写入 SQLite。
React 组件中点击“上传照片” -> 调用 C++ 打开原生文件选择对话框。

第四阶段：可视化与业务功能 (应用层)
这里我们要充分利用 混合架构 的优势：

家族树谱系图 (React + D3.js/Cytoscape.js):

为什么用 Web? 复杂的树状拓扑图在 Web 前端有非常成熟的库（如 React Flow），比用 QGraphicsView 写起来快得多且效果炫酷。

功能：展示无限层级的家谱树，支持缩放、拖拽、点击查看详情。

成员详情编辑 (Qt Widgets / QML):

为什么用 Native? 表单录入、日期选择、文件管理，原生控件体验更好，且这部分功能不需要花哨的特效。

大事年表 (Timeline):

以时间轴的方式展示家族或个人的生平大事。

多媒体库:

照片墙、老视频播放（利用 CEF 或 Qt Multimedia）。

第五阶段：导入导出与部署
GEDCOM 标准支持:

实现 GEDCOM (家谱数据交换标准格式) 的解析与导出，让用户能迁移数据。

打包发布:

Windows: 使用 CPack/NSIS 打包成安装程序 (包含 VC Redist, WebView2 依赖)。

Linux: 打包成 .deb 或 .AppImage (解决依赖地狱)。
